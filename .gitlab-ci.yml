# vim: tabstop=4 shiftwidth=4 softtabstop=4

default:
    image: "jlk.fjfi.cvut.cz:5000/fjfi-mmg/archlinux-tnl-cuda:latest"
    tags:
        - docker
    retry:
        max: 1
        when:
            - api_failure
            - runner_system_failure
            - stuck_or_timeout_failure

stages:
    - lint
    - build
    - build:cuda
    - build:hip_rocm
    - build:host
    - build:doc
    - deploy

# https://docs.gitlab.com/ee/ci/yaml/workflow.html
workflow:
    rules:
        # run a pipeline in the merge request context
        - if: $CI_PIPELINE_SOURCE == "merge_request_event"
        # don't run a branch pipeline on push when there is an open merge request
        - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS
          when: never
        # otherwise run a branch pipeline
        - if: $CI_COMMIT_BRANCH

# default flags for cmake
.default_cmake_flags: &default_cmake_flags
    # architectures
    USE_CUDA: "no"
    USE_HIP: "no"
    # MPI is selectively added to targets, so there is no point to have separate jobs without MPI
    USE_MPI: "yes"
    USE_OPENMP: "yes"
    # build targets
    BUILD_COVERAGE: "no"
    BUILD_DOC: "no"  # only used in the "documentation" job
    # toolchain flags defaults
    CMAKE_CXX_FLAGS: ""
    CMAKE_CUDA_FLAGS: ""
    CMAKE_EXE_LINKER_FLAGS: ""
    CMAKE_SHARED_LINKER_FLAGS: ""

# base for GCC builds
.gcc:
    stage: build:host
    variables:
        <<: *default_cmake_flags
        CXX: g++
        CC: gcc

# base for NVCC builds
.nvcc:
    stage: build:cuda
    tags:
        - docker
        - nvidia
    variables:
        <<: *default_cmake_flags
        USE_CUDA: "yes"

# base for NVHPC builds
.nvhpc:
    image: "jlk.fjfi.cvut.cz:5000/fjfi-mmg/archlinux-tnl-nvhpc:latest"
    variables:
        <<: *default_cmake_flags
        USE_CUDA: "yes"
        CXX: nvc++
        CC: nvc
        CUDACXX: nvcc
        CUDAHOSTCXX: nvc++

# base for Clang builds
.clang:
    stage: build:host
    variables:
        <<: *default_cmake_flags
        CXX: clang++
        CC: clang
        CUDAHOSTCXX: clang++
        # also use LLVM's libc++ instead of GCC's libstdc++ (which is used by default)
        CMAKE_CXX_FLAGS: "-stdlib=libc++"
        # use the LLVM linker and link to libc++
        CMAKE_EXE_LINKER_FLAGS: "-fuse-ld=lld -lc++ -lc++abi"
        CMAKE_SHARED_LINKER_FLAGS: "-fuse-ld=lld -lc++ -lc++abi"

# base for Clang CUDA builds
.clang_cuda:
    stage: build:cuda
    tags:
        - docker
        - nvidia
    extends: .clang
    image: "jlk.fjfi.cvut.cz:5000/fjfi-mmg/archlinux-tnl-cuda:latest"
    variables:
        CUDACXX: clang++
        CUDAHOSTCXX: clang++
        # CUDA does not support libc++ on x86 systems
        CMAKE_CUDA_FLAGS: "-stdlib=libstdc++"
        CMAKE_CXX_FLAGS: "-stdlib=libstdc++"
        CMAKE_EXE_LINKER_FLAGS: "-fuse-ld=lld"
        CMAKE_SHARED_LINKER_FLAGS: "-fuse-ld=lld"
        USE_CUDA: "yes"
        # use CUDA from the Arch Linux-based container image
        "CUDA_PATH": "/opt/cuda"
        "Thrust_DIR": "${CUDA_PATH}/lib64/cmake/thrust/"
        "CUB_DIR": "${CUDA_PATH}/lib64/cmake/cub/"

# base for Intel oneAPI builds
.icpx:
    stage: build:host
    image: "jlk.fjfi.cvut.cz:5000/fjfi-mmg/archlinux-tnl-oneapi:latest"
    variables:
        <<: *default_cmake_flags
        CXX: icpx
        CC: icx

# base for HIP/ROCm builds
.hip_rocm:
    stage: build:hip_rocm
    image: "jlk.fjfi.cvut.cz:5000/fjfi-mmg/archlinux-tnl-rocm:latest"
    tags:
        - docker
        - hip-rocm
    variables:
        <<: *default_cmake_flags
        USE_HIP: "yes"
        USE_OPENMP: "no"   # TODO: enabling OpenMP leads to false warnings due to unused variable

# template for environment setup before build
.env_setup: &env_setup
    - CUDA_PATH_BACKUP=$CUDA_PATH
    # make sure that $PATH and other essential variables are set correctly
    - source /etc/profile
    # restore $CUDA_PATH if it was set as a variable in the CI
    - if [[ -n ${CUDA_PATH_BACKUP} ]]; then
            export CUDA_PATH=${CUDA_PATH_BACKUP};
      fi
    # all cores including hyperthreading
    #- export NUM_CORES=$(grep "core id" /proc/cpuinfo | wc -l)
    # all physical cores
    - export NUM_CORES=$(grep "core id" /proc/cpuinfo | sort -u | wc -l)
    - export CTEST_OUTPUT_ON_FAILURE=1
    - export CTEST_PARALLEL_LEVEL=4
    - export OMP_NUM_THREADS=4
    # running as root does not matter inside Docker containers
    - export OMPI_ALLOW_RUN_AS_ROOT=1
    - export OMPI_ALLOW_RUN_AS_ROOT_CONFIRM=1

# template for build jobs
.build_template:
    # don't wait for jobs in previous stages to complete before starting this job
    needs: []
    script:
        - *env_setup
        # handle the $MATRIX_TARGET variable from .matrix_template
        - if [[ ${MATRIX_TARGET} == "tests" ]]; then
                BUILD_TARGETS=("non-matrix-tests");
          elif [[ ${MATRIX_TARGET} == "matrix_tests" ]]; then
                BUILD_TARGETS=("matrix-tests");
          elif [[ ${MATRIX_TARGET} == "nontests" ]]; then
                BUILD_TARGETS=("benchmarks" "examples" "tools");
          elif [[ ${BUILD_DOC} == "yes" ]]; then
                BUILD_TARGETS=("documentation");
          fi
        - cmake -B "./build/$CI_JOB_NAME_SLUG" -S . -G Ninja
                -DCMAKE_BUILD_TYPE=${BUILD_TYPE}
                -DCMAKE_INSTALL_PREFIX="$(pwd)/install_prefix/$CI_JOB_NAME_SLUG"
                -DCMAKE_CXX_FLAGS="${CMAKE_CXX_FLAGS}"
                -DCMAKE_CUDA_FLAGS="${CMAKE_CUDA_FLAGS}"
                -DCMAKE_EXE_LINKER_FLAGS="${CMAKE_EXE_LINKER_FLAGS}"
                -DCMAKE_SHARED_LINKER_FLAGS="${CMAKE_SHARED_LINKER_FLAGS}"
                -DTNL_USE_OPENMP=${USE_OPENMP}
                -DTNL_USE_MPI=${USE_MPI}
                -DTNL_USE_CUDA=${USE_CUDA}
                -DTNL_USE_HIP=${USE_HIP}
                -DTNL_BUILD_COVERAGE=${BUILD_COVERAGE}
                -DTNL_USE_CI_FLAGS=yes
        # build the given targets
        - cmake --build "./build/$CI_JOB_NAME_SLUG" --parallel ${NUM_CORES} --target "${BUILD_TARGETS[@]}"
        # we have ctest options set in the preset, but ctest does not allow to override the build directory
        # https://gitlab.kitware.com/cmake/cmake/-/issues/23982
        - "sed 's|\"binaryDir\": \"${sourceDir}/build\",|\"binaryDir\": \"${sourceDir}\",|' CMakePresets.json > \"./build/$CI_JOB_NAME_SLUG/CMakePresets.json\""
        - pushd "./build/$CI_JOB_NAME_SLUG/"
        # NOTE: execution of HIP tests is temporarily skipped until we get a reliable GPU
        - if [[ ${MATRIX_TARGET} == "tests" ]] && [[ ${USE_HIP} != "yes" ]]; then
                ctest --preset non-matrix-tests --output-junit "./tests-report.xml";
          elif [[ ${MATRIX_TARGET} == "matrix_tests" ]] && [[ ${USE_HIP} != "yes" ]]; then
                ctest --preset matrix-tests --output-junit "./tests-report.xml";
          fi
        - popd
    rules:
        - changes:
            - src/**/*.{h,hpp,cpp,cu,hip}
            - "**/CMakeLists.txt"
            - cmake/*
            - .gitlab-ci.yml
    interruptible: true

.matrix_template:
    parallel:
        matrix:
            - MATRIX_TARGET:
                - tests
                - matrix_tests
                - nontests
              BUILD_TYPE:
                - Debug
                - Release

# template for collecting code coverage
.coverage_template:
    # NOTE: gcovr is very slow, maybe it could be solved with fastcov:
    # https://github.com/gcovr/gcovr/issues/289
    # https://github.com/RPGillespie6/fastcov
    # NOTE: when enabling, the BUILD_COVERAGE env var must be switched to yes
    #after_script:
    #    - mkdir coverage_html
    #    - if [[ ${CXX} == "clang++" ]]; then
    #            GCOV_COMMAND="llvm-cov gcov";
    #      else
    #            GCOV_COMMAND="gcov";
    #      fi
    #    - gcovr --print-summary --html-details coverage_html/coverage.html --xml coverage.xml --xml-pretty --gcov-executable "${GCOV_COMMAND}" --exclude-unreachable-branches --root "${CI_PROJECT_DIR}" --filter "${CI_PROJECT_DIR}/src/TNL/"
    coverage: /^\s*lines:\s*\d+.\d+\%/
    artifacts:
        name: ${CI_JOB_NAME_SLUG}-${CI_COMMIT_REF_NAME}-${CI_COMMIT_SHA}
        expire_in: 7 days
        reports:
            coverage_report:
                coverage_format: cobertura
                path: coverage.xml
            junit: "build/$CI_JOB_NAME_SLUG/tests-report.xml"
        paths:
            - coverage_html/

# template for registering tests-report.xml as an artifact
.tests_report_template:
    artifacts:
        name: ${CI_JOB_NAME}-${CI_COMMIT_REF_NAME}-${CI_COMMIT_SHA}
        expire_in: 7 days
        reports:
            junit: "build/$CI_JOB_NAME_SLUG/tests-report.xml"

# Dummy build job to ensure that a pipeline is created for a merge request, even
# when there were no changes.
dummy build job:
    stage: build
    script: echo "dummy"
    only:
        - merge_requests
    except:
        changes:
            # .build_template
            - src/**/*.{h,hpp,cpp,cu,hip}
            - "**/CMakeLists.txt"
            - cmake/*
            - .gitlab-ci.yml
            # build documentation
            - Documentation/**/*





nvcc:
    extends:
        - .build_template
        - .matrix_template
        - .nvcc

nvhpc:
    stage: build:cuda
    tags:
        - docker
        - nvidia
    extends:
        - .build_template
        #- .matrix_template
        - .nvhpc
    # NOTE: nvc++ has huge memory requirements for matrix tests in Release, so we skip them from the matrix
    parallel:
        matrix:
            - MATRIX_TARGET:
                - tests
                - matrix_tests
                - nontests
              BUILD_TYPE:
                - Debug
            - MATRIX_TARGET:
                - tests
                - nontests
              BUILD_TYPE:
                - Release

clang_cuda:
    extends:
        - .build_template
        - .matrix_template
        - .clang_cuda


hip_rocm:
    extends:
        - .build_template
        - .matrix_template
        - .hip_rocm


gcc:
    extends:
        - .build_template
        - .matrix_template
        - .gcc

clang:
    extends:
        - .build_template
        - .matrix_template
        - .clang

icpx:
    extends:
        - .build_template
        - .matrix_template
        - .icpx





alpine:
    stage: build:host
    # NOTE: library/alpine does not have bash, so the .build_template script fails
    #image: "docker.io/library/alpine:latest"
    image: "docker.io/library/bash:latest"
    before_script:
        - apk add build-base git cmake ninja openmpi-dev zlib-dev
        # instruct mpirun to not use ssh
        - export OMPI_MCA_plm_rsh_agent=sh
    extends:
        - .build_template
        - .matrix_template
        #- .gcc
    variables:
        <<: *default_cmake_flags
        CXX: g++
        CC: gcc
        # avoid spurious error due to Alpine's GCC
        CMAKE_CXX_FLAGS: "-Wno-error=array-bounds"

debian:
    stage: build:host
    image: "docker.io/${IMAGE_NAME}"
    before_script:
        - apt-get update
        # workaround for gfortran problem in the gcc images
        # (there is a local gfortran that conflicts with the alternatives system)
        - if test -f /usr/local/bin/gfortran; then
              ln -s /usr/local/bin/gfortran /usr/bin/gfortran;
          fi
        # install new cmake
        - wget -q https://github.com/Kitware/CMake/releases/download/v4.0.1/cmake-4.0.1-linux-x86_64.sh
        - bash cmake-4.0.1-linux-x86_64.sh --skip-license --prefix=/usr
        # install dependencies for TNL
        - apt-get install -y build-essential git ninja-build libopenmpi-dev zlib1g-dev
        # select the compiler
        - if command -v clang++; then
              export CXX=clang++;
              export CC=clang;
          else
              export CXX=g++;
              export CC=gcc;
          fi
    extends:
        - .build_template
    parallel:
        matrix:
            - MATRIX_TARGET:
                - tests
              BUILD_TYPE:
                - Debug
              IMAGE_NAME:
                # https://hub.docker.com/_/gcc
                - gcc:12
                - gcc:13
                - gcc:14
                - gcc:15
                # https://hub.docker.com/r/silkeh/clang
                - silkeh/clang:10
                - silkeh/clang:11
                - silkeh/clang:12
                - silkeh/clang:13
                #- silkeh/clang:14  # segfaults in tests execution
                #- silkeh/clang:15  # segfaults in tests execution
                #- silkeh/clang:16  # segfaults in tests execution
                - silkeh/clang:17
                - silkeh/clang:18
                - silkeh/clang:19
                - silkeh/clang:20





documentation:
    extends: .build_template
    stage: build:cuda
    tags:
        - docker
        - nvidia
    variables:
        <<: *default_cmake_flags
        USE_OPENMP: "yes"
        USE_CUDA: "yes"
        USE_MPI: "yes"
        BUILD_TYPE: Debug
        # build output snippets for documentation
        BUILD_DOC: "yes"
    rules:
        - changes:
            - Documentation/**/*
            - src/TNL/**/*.{h,hpp}
            - .gitlab-ci.yml
    # store the built documentation for deployment
    after_script:
        - mv "./build/$CI_JOB_NAME_SLUG/Documentation/html" "./html"
    artifacts:
        paths:
            - ./html/
        expire_in: 7 days

pages:
    stage: deploy
    rules:
        - if: $CI_PIPELINE_SOURCE == "schedule" || $CI_PIPELINE_SOURCE == "trigger" || $CI_COMMIT_BRANCH == "main"
          changes:
            - Documentation/**/*
            - src/TNL/**/*.{h,hpp}
            - .gitlab-ci.yml
    # use "dependencies" instead of "needs" to deploy only when the entire pipeline succeeds
    dependencies:
        - documentation
    image: "quay.io/archlinux/archlinux:latest"
    script:
        - mv ./html/ public/
    artifacts:
        paths:
            - public

clang-format:
    stage: lint
    rules:
        - changes:
            - Documentation/**/*.{h,hpp,cpp,cu,hip}
            - src/TNL/**/*.{h,hpp,cpp,cu,hip}
            - .clang-format
            - scripts/run-clang-format.py
            - .gitlab-ci.yml
    image: "quay.io/archlinux/archlinux:latest"
    before_script:
        - pacman -Syu --needed --noconfirm clang python
    script:
        - ./scripts/run-clang-format.py
                --color always
                --style file
                --exclude "src/TNL/3rdparty/*"
                --recursive
                Documentation
                src
    interruptible: true

clang-tidy:
    stage: lint
    rules:
        - changes:
            - Documentation/**/*.{h,hpp,cpp,cu,hip}
            - src/**/*.{h,hpp,cpp,cu,hip}
            - "**/CMakeLists.txt"
            - cmake/*
            - .clang-tidy
            - .gitlab-ci.yml
    variables:
        CXX: clang++
        CC: clang
    script:
        # configure only to generate compile_commands.json
        - cmake -B "./build/$CI_JOB_NAME_SLUG" -S . -G Ninja
                -DCMAKE_BUILD_TYPE=Debug
                -DTNL_USE_OPENMP=yes
                -DTNL_USE_MPI=yes
                -DTNL_USE_CUDA=no
                -DTNL_USE_CI_FLAGS=yes
        # cmake creates compile_commands.json only on the second run, WTF!?
        - cmake -B "./build/$CI_JOB_NAME_SLUG" -S . -G Ninja
        - ls -lah "./build/$CI_JOB_NAME_SLUG"
        # run-clang-tidy is weird compared to run-clang-format.py:
        # - clang-tidy is not executed on header files, but on source files
        # - the positional arguments are regexes filtering sources from the compile_commands.json
        # - the -header-filter option (or HeaderFilterRegex in the config) allows to filter header files
        # - "build/.*" must be excluded on run-clang-tidy command line as it
        #   includes targets generated by CMake's FetchContent module
        - run-clang-tidy -p "./build/$CI_JOB_NAME_SLUG" "$PWD/Documentation/.*" "$PWD/src/.*"
    interruptible: true
    # TODO: remove to enforce
    allow_failure: true

cmake-format:
    stage: lint
    rules:
        - changes:
            - "**/CMakeLists.txt"
            - "**/*.cmake"
            - .cmake-format.yaml
            - .gitlab-ci.yml
    script:
        - shopt -s globstar
        - cmake-format --in-place **/CMakeLists.txt cmake/**/*.*
        - git --no-pager diff --color=always --exit-code
    interruptible: true

copyright-headers:
    stage: lint
    rules:
        - changes:
            - src/**/*.{h,hpp,cpp,cu,hip}
            - scripts/updage-copyright-headers.py
            - .gitlab-ci.yml
    image: "quay.io/archlinux/archlinux:latest"
    before_script:
        - pacman -Syu --needed --noconfirm git python
    script:
        - ./scripts/update-copyright-headers.py
                --dir src/
                --exclude
                    'src/TNL/3rdparty/*'
                    'src/UnitTests/*'
                    'src/Benchmarks/Sorting/ReferenceAlgorithms/*'
                    'src/Examples/Hypre/*'
        - git --no-pager diff --color=always --exit-code
    interruptible: true

python-black:
    stage: lint
    rules:
        - changes:
            - src/**/*.py
            - Documentation/**/*.py
            - .gitlab-ci.yml
    image: "quay.io/archlinux/archlinux:latest"
    before_script:
        - pacman -Syu --needed --noconfirm python-black python-colorama
    script:
        - black --color --diff --check Documentation/ src/
    interruptible: true
